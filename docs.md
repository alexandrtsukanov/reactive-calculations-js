Reactive:

    Функции от сущностей:

    1) fromValue - примитивы. Числа. Поддерживаемые виды данных - number, bigint, undefined?, symbol?, NaN?
    2) fromBoolean - булины. Поддерживаемые виды данных - boolean
    3) fromIterable - итерабл-объекты. Массивы, строки, мапы, сеты, кастомные итераблы. Поддерживаемые виды данных - string, Array, Map, Set
    4) fromObject - объекты, неитерабл асоциативные массивы. Поддерживаемые виды данных - Object, null?
    5) fromFunction - функции. Поддерживаемые виды данных - function
    6) fromAsync - ???

AsyncReactive:

    Функции от сущностей:

    1) fromValue - примитивы. Числа. Поддерживаемые виды данных - number, bigint, undefined?, symbol?, NaN?
    2) fromBoolean - булины. Поддерживаемые виды данных - boolean
    3) fromIterable - итерабл-объекты. Массивы, строки, мапы, сеты, кастомные итераблы. Поддерживаемые виды данных - string, Array, Map, Set
    4) fromObject - объекты, неитерабл асоциативные массивы. Поддерживаемые виды данных - Object, null?
    5) fromFunction - функции. Поддерживаемые виды данных - function
    6) fromAsync - ???

Свойства реактива:
    
    value - значение. Не давать получать значение извне. Дефолт - null (скорее всего)
    deps - прямой граф
    depsReversed - обратный граф
    rules - коллбэки зависимостей
    isSrict - строгая ли зависимость

    Скорее всего, нужны типизированные реактивы на каждый тип (можно через наследование классов)

Структура зависиместей:

    Граф: influences - Map{[source: Reactive]: Set(dep: Reactive)} - от источника зависимости к зависимому реактиву;
    Обратный граф: dependencies - Map{[dep: Reactive]: Set{source: Reactive}} - от зависимого реактива к источнику зависимости;
    При вызове методов break, breakAll, free, freeAll обновляются оба графа
    При вызове метода update помимо обновления значения делается dfs в прямом графе с обновлением значения у всех зависимых узлов через соответсвующий коллбэк
    Отдельно для каждой зависисмости хранить коллбек зависимости rules: Map{[dep: Reactive]: callback}. Если зависимость пустая, можно null
    Пустое значение Reactive: если у реактива пустая зависимость (нет значения), а есть только зависимые от него реактивы, то в dfs при апдейте делать проверку на наличие коллбэка
    При инициализации зависимости (from, setDep) можно опционольно указать, строгая ли зависимость или нет. Если строгая - нельзя апдейтить зависимый реактив напрямую. Можно передать как options {strict: true}. Информацию об этом хранить в свойствах реактива

API:

    Общие методы:

    from(reactives: ...[Reactive | AsyncReactive]): Reactive | AsyncReactive - инициализация зависимости в момент создания
    getValue(): Reactive | AsyncReactive - получение значения. Не давать получать значение извне.
    depend(fn: (values: any[]) => newValue: any): void - инициализация правила зависимости. Проверить количество зависимых узлов относительно переданных аргументов. Не дать вызвать, если ни от чего не зависит. Инициализировать зависимые реактивы через этот коллбэк
    setDep(source: Reactive | AsyncReactive, deps: [Reactive | AsyncReactive], fn: (args: any[]) => value: any) - инициализация зависимости в рандомный момент. Проверка, чтоб не было циклических зависимостей!
    setValue(value: any): void - инициаллизация значения Reactive ???
    update(value: any | fn: (args: any[]) => value: any): void - изменение значения. Не дать вызвать, если нет значения (пустая зависимость). Менять можно как чрезе коллбэк отночитлеьно предыдущего значения, так и напрямую засетить новое значение
    break(reactives: ...Reactive[] | AsyncReactive[]): void - удаление зависимости со стороны источника зависимости
    breakAll(): void - удаление всех зависимостей со стороны источника зависимостей
    free(reactives: ...Reactive[] | AsyncReactive[]): void - удаление зависимости со стороны зависящей сущности
    freeAll(): void - удаление всех зависимостей со стороны зависящей сущности

    Методы fromValue:

    depend(fn: (values: any[]) => newValue: any): void - инициализация правила зависимости. Проверить количество зависимых узлов относительно переданных аргументов. Не дать вызвать, если ни от чего не зависит. Инициализировать зависимые реактивы через этот коллбэк

    Методы fromBoolean:

    same() - такое же значение
    opposite() - противоположное значение

    Методы fromArray:

    методы апдейта массива: - наверное, без них! Лишний синтаксический шум
        updateMap(callback)
        updateFlatMap(callback)
        updateFilter(callback)
        updateConcat(callback)

    map(fn: (el: any, index?: number, array?: Array) => newEl: any) - зависимость через map, коллбэк применяется к каждому элементу
    filter(fn: (el: any, index?: number, array?: Array) => boolean) - зависимость через filter, коллбэк применяется к каждому элементу. Зависимость ограничивает наличие попределенных элементов
    flatMap(fn: (el: any) => Array<newEl>) - зависимость через монадический метод, коллбэк применяется к каждому элементу
    concat() - зависмость через добавление в конец, гарантирует добавление элементов в конце

    Строки - как у fromValue

    Методы fromInterable:

    Сначала суть: коллбэк зависимости будет применяться к каждому value зависящего итерабла. На основе этого у зависимого итерабла создаем новый [Symbol.iterator](), на каждом next() применяем коллбэк к value. Короче, апдейтим итератор. А теперь методы:

    Методы апдейта итарабла - да наверно те же, что и у массива (updateFlatMap?)

    map(fn: (el: any, index?: number, iterable?: Iterable) => newEl: any) - зависимость как у map
    take(limit: number) - ограничиваем перебор элементов с начала. Если лимит больше чем длина исходного, то не выводить андефанйды и огрничить длиной исходного!
    takeLast(limit: number) - ограничиваем перебор элементов с конца. Если лимит больше чем длина исходного, то не выводить андефанйды и огрничить длиной исходного!
    revesre() - обратный итератор
    filter(fn: (el: any, index?: number, iterable?: Iterable) => boolean) - ограничивает вывод определнных элементов

    Методы fromObject:

    depend(как-то так можно [[key1, fn1], [key2, fn2], ...], где fnN меняет значение) - общая описание зависимости
    pick({key1: value1, key2: value2}: Object) - зависимсоть, где добавляются поля
    omit({key1: value1, key2: value2}: Object) - зависимсоть, где вырезаются поля 

    Методы fromFunction:
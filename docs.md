Reactive:

    Функции от сущностей:

    1) fromValue - примитивы. Числа. Поддерживаемые виды данных - number, bigint, undefined?, symbol?, NaN?
    2) fromBoolean - булины. Поддерживаемые виды данных - boolean
    3) fromIterable - итерабл-объекты. Массивы, строки, мапы, сеты, кастомные итераблы. Поддерживаемые виды данных - string, Array, Map, Set
    4) fromObject - объекты, неитерабл асоциативные массивы. Поддерживаемые виды данных - Object, null?
    5) fromFunction - функции. Поддерживаемые виды данных - function
    6) fromAsync - ???

AsyncReactive:

    Функции от сущностей:

    1) fromValue - примитивы. Числа. Поддерживаемые виды данных - number, bigint, undefined?, symbol?, NaN?
    2) fromBoolean - булины. Поддерживаемые виды данных - boolean
    3) fromIterable - итерабл-объекты. Массивы, строки, мапы, сеты, кастомные итераблы. Поддерживаемые виды данных - string, Array, Map, Set
    4) fromObject - объекты, неитерабл асоциативные массивы. Поддерживаемые виды данных - Object, null?
    5) fromFunction - функции. Поддерживаемые виды данных - function
    6) fromAsync - ???

Свойства реактива:
    
    value - значение. Не давать получать значение извне. Дефолт - null (скорее всего)
    dependencies - граф цепочки зависимостей, в графе будут кортежи [значение, коллбэк зависимости]
    dependencies - граф обратной цепочки зависимостей - ???. Либо хранить у каждого реактива старт цепочки зависимостей ??? Либо уддалть зависимость со стороны источника зависимости
    rules - коллбэки зависимостей - ???
    isStrict - строгая ли зависимость
    start - начальный реактив цепочки зависимостей ???
    isFree - свободная ли или зависит от кого

    Скорее всего, нужны типизированные реактивы на каждый тип (можно через наследование классов)

Структура зависиместей:

    Граф: dependencies - Map{[source: Reactive]: Set(dep: [Reactive, callback])} - от источника зависимости к зависимому реактиву;
    Возможно, без кортежей, но отдельно сделать отдельно Map {зависимый реактив -> коллбэк зависимости}
    Отдельно для каждой зависисмости хранить коллбек зависимости rules: Map{[dep: Reactive]: callback}. Если зависимость пустая, можно null
    Обратный граф: dependencies - Map{[dep: Reactive]: Set{source: Reactive}} - от зависимого реактива к источнику зависимости - ???;
    При вызове методов break, breakAll, free, freeAll обновляются оба графа - ???
    При удалении зависимости удалять дальнейшие зависимости только сверху в цепочке
    При вызове метода update помимо обновления значения делается dfs в прямом графе с обновлением значения у всех зависимых узлов через соответсвующий коллбэк
    Пустая зависмость - наверное, значение undefined или null, коллбэк - null
    Пустое значение Reactive: если у реактива пустая зависимость (нет значения), а есть только зависимые от него реактивы, то в dfs при апдейте делать проверку на наличие коллбэка и (или) значения
    При инициализации зависимости (from, depend) можно опционольно указать, строгая ли зависимость или нет. Если строгая - нельзя апдейтить зависимый реактив напрямую. Можно передать как options {strict: true}. Информацию об этом хранить в свойствах реактива

API:

    Общие методы:

    from(reactives: ...[Reactive | AsyncReactive]): Reactive | AsyncReactive - инициализация зависимости в момент создания
    getValue(): Reactive | AsyncReactive - получение значения. Не давать получать значение извне.
    depend(fn: (values: any[]) => newValue: any): void - инициализация правила зависимости. Проверить количество зависимых узлов относительно переданных аргументов - должны быть равны, иначе исключение ?. Не дать вызвать, если ни от чего не зависит (?). Инициализировать зависимые реактивы через этот коллбэк. Сделать возможность цепочек вызовов метода при инициализации зависимости
    dependsOn(source: Reactive | AsyncReactive, deps: [Reactive | AsyncReactive], fn: (args: any[]) => value: any) - инициализация зависимости в рандомный момент. Проверка, чтоб не было циклических зависимостей!
    setValue(value: any): void - инициаллизация значения Reactive ???
    update(value: any | fn: (args: any[]) => value: any): void - изменение значения. Не дать вызвать, если нет значения (пустая зависимость). Менять можно как через коллбэк отночитлеьно предыдущего значения, так и напрямую засетить новое значение
    free(reactives: ...Reactive[] | AsyncReactive[]): void - удаление зависимости со стороны источника зависимости
    freeAll(): void - удаление всех зависимостей со стороны источника зависимостей - ???
    break(reactives: ...Reactive[] | AsyncReactive[]): void - удаление зависимости со стороны зависящей сущности - ???
    breakAll(): void - удаление всех зависимостей со стороны зависящей сущности - ???

    Методы fromValue:

    depend(fn: (values: any[]) => newValue: any): void - инициализация правила зависимости. Проверить количество зависимых узлов относительно переданных аргументов. Не дать вызвать, если ни от чего не зависит. Инициализировать зависимые реактивы через этот коллбэк

    Методы fromBoolean:

    same() - такое же значение
    opposite() - противоположное значение
    toggle() - метод апдейта

    Методы fromArray:

    методы апдейта массива: - наверное, без них! Лишний синтаксический шум
        updateMap(callback)
        updateFlatMap(callback)
        updateFilter(callback)
        updateConcat(callback)

    map(fn: (el: any, index?: number, array?: Array) => newEl: any) - зависимость через map, коллбэк применяется к каждому элементу
    filter(fn: (el: any, index?: number, array?: Array) => boolean) - зависимость через filter, коллбэк применяется к каждому элементу. Зависимость ограничивает наличие попределенных элементов
    flatMap(fn: (el: any) => Array<newEl>) - зависимость через монадический метод, коллбэк применяется к каждому элементу
    push() - зависмость через добавление в конец, гарантирует добавление элементов в конце
    unshift() - зависмость через добавление в конец, гарантирует добавление элементов в начале
    revesre() - массив наоборот

    Строки - как у fromValue

    Методы fromInterable:

    Будут итерабл-объекты либо сами итероторы
    Сначала суть: коллбэк зависимости будет применяться к каждому value зависящего итерабла. На основе этого у зависимого итерабла создаем новый [Symbol.iterator](), на каждом next() применяем коллбэк к value. Короче, апдейтим итератор. А теперь методы:

    Методы апдейта итарабла - да наверно те же, что и у массива (updateFlatMap?)

    map(fn: (el: any, index?: number, iterable?: Iterable) => newEl: any) - зависимость как у map
    take(limit: number) - ограничиваем перебор элементов с начала. Если лимит больше чем длина исходного, то не выводить андефанйды и огрничить длиной исходного!
    takeLast(limit: number) - ограничиваем перебор элементов с конца. Если лимит больше чем длина исходного, то не выводить андефанйды и огрничить длиной исходного!
    revesre() - обратный итератор
    filter(fn: (el: any, index?: number, iterable?: Iterable) => boolean) - ограничивает вывод определнных элементов

    Методы fromObject:

    depend(как-то так можно [[key1, fn1], [key2, fn2], ...], где fnN меняет значение) - общее описание зависимости
    pick({key1: value1, key2: value2}: Object) - зависимсоть, где добавляются поля
    omit(keys: string[]) - зависимсоть, где вырезаются поля
    flatMap(fn: (val: any) => obj: Object) - монадический метод, коллбэк принимает другой тип данных (примитив или экземпляр другого класса), возвращает строго объект
    map(fn: (val: any) => newVal: any) - функторный метод, типа как flatMap, только коллбэк возвращает простой тип данныхБ не (обязательно) объект

    Методы fromFunction:

    Суть - зависимость функции сводится к pipe: 1. есть коллбэк зависимости, 2. зависящая функция вызывается 3. возвращенное ей значение передается в коллбэк как аргумент, и коллбэк вычисляет новое значение
    Методы:
    depend(fn: (values: any[]) => newValue: any): void - инициализация правила зависимости. 

    Асинхронные события браузера:

    Суть - через функцию on. fromDOMEvent принимает источник событий (DOM-элемент) и событие. Их передаем в on, возвращающую асинхронный итератор. Создать далее метод (then), который ловит асинхронное событие и по цепочке зависимостей асинхронно апдейтит значения у всех зависимых реактивов. У промисов, наверное, как-то так же.
    Методы:
    map(fn: (val: any) => newVal: any) - функторный метод, коллбэк возвращает простой тип данныхБ не (обязательно) объект, пробразует собитые
    flatMap(fn: (val: any) => obj: Object) - монадический метод, коллбэк принимает другой тип данных (примитив или экземпляр другого класса), возвращает строго объект, пробразует собитые
    filter(fn: (el: any) => boolean) - ограничивает поимку определнных событий

    Промисы:

    Суть - как и простые примитивы, но при построении цепочки зависимостей можно попробовать использовать цепочку промисов (then). prevPromise.then(val => callback(val))
    Методы:
    depend(fn: (values: any[]) => newValue: any): void - инициализация правила зависимости.

    Регулярки:

    Методы:
    addFlags(...flags) - добавляет флаги
    removeFlags(...flags) - удаляет флаги

    Попробовать:

    даты, реакт-компоненты, HTML-элементы, ошибки

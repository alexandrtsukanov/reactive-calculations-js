## reactive-calculations-js

Библиотека для реактивных вычислений.

Настоящая библиотека позволяет создавать одни сущности зависимости от других. Зависимость одной сущности от другой инициализируется в момент ее создания. При изменении первой сущнонсти зависимые от нее сущности меняются автоматически.

# Определения

Для удобства понимания дадим следующие определения:

*Реактив* - объект, реализующий API созидания и управления зависимостями, основная единица настоящей библиотеки. Является инстансом класса `Reactive` и наследуемых от него классов. Изолирован относительно типов данных, которые в себе хранит. То есть для чисел применяется отдельный реактив, для строк - отдельный, для итерабл-объектов - отдельный и так далее. Изоляция по типам в библиотеке существует по причинам: 1) чтобы не дать выполнить какую-либо арифметическую операцию между, например, числом и массивом (защита от NaN), 2) чтобы удобно расширить API реактива для разных типов js-данных в зависимсоти от их сигнатуры (подробнее об этом ниже). Значение по умолчанию - `null`.

Реактив создается группой методов, начинающихся с `create...`:

+ Для чисел - `createVal`
+ Для строк - `createStr`
+ Для булевых значений - `createBoolean`
+ Для массивов - `createArray`
+ Для объектов - `createObject`
+ Для произвольных итерабл-объектов - `createIterable`
+ Для функций - `createFunction`
+ Для промисов - `createPromise`
+ Для регулярных выражений - `createRegExp`
+ Отдельно реалозована возможность создавать зависимости от DOM-событий (посредством метода `createObject`, так как DOM-событие - это по факту объект) - через метод `createDOMEvent`

Библиотека не поддерживает тип данных `undefined`.

*Зависимость* - состояние, при котором сущность Б зависит от сущности Б, Б автоматичкски меняется при изменении А по определенному алгоритму (о котором речь пойдет ниже), А управляет заначением Б. 
Зависимость может создаваться 2-мя путями - 1) при инициализации сущности и 2) в рандомный момент. Зависимость при инициализации - это когда зависимсть создается сразу же в момент создания сущности, то есть мы создаем сущность уже как зависимую от другой. Зависимость в рандомный момент - это когда мы создаем зависимость одной сущности от другой в любой момент времени, когда мы этого хотим, то есть есть сущности А и Б, они живут себе как независимые, и мы в определенном месте говорим: Б теперь зависит от А.

Создание зависимости при инициализации происходит через вызов группы методов, начинающихся с `from...`, куда мы передаем реактив(ы), от которых новая сущность зависит (может зависеть и от нескольких реактивов). Аналогично методам `create...`, `from...` изолирован по типам данных:

+ Для чисел - `fromNum`
+ Для строк - `fromStr`
+ Для булевых значений - `fromBool`
+ Для массивов - `fromArr`
+ Для объектов - `fromObj`
+ Для произвольных итерабл-объектов - `fromIter`
+ Для функций - `fromFn`
+ Для промисов - `fromProm`
+ Для регулярных выражений - `fromRe`

Создание зависимости в рандомный момент происходит через вызов метода `dependOn` у реактива, вызывается у реактива, который зависит, аргументом передается реактив(ы), от которого зависит.

*Правило зависимости* - функция-коллбэк, которая говорит, каким образом Б зависит от А. Передается в метод реактива `depend`. Например, правило `value => value * 2` говорит о том, что при зависимости Б от А Б в любой момент времени больше А в 2 раза (пока Б зависит от А). Применение: `const b = fromNum(a).depend(value => value * 2)` или `b.dependsOn(a).depend(value => value * 2)`. В библиотеке предусмотрено, чтобы правило зависимости всегда, неважно, в каком месте цепочки находится реактив, принимал строго такое количество аргументов, как и количество сущностей, от которых он зависит. В случае несовпадения выбрасывается исключение.

*Родитель зависимости* - сущность, от которой зависит другая сущность.

*Ребенок зависимостей* - сущность, которая зависит от другой сущности. Так, если Б зависит от А, то А будет родителем, Б - ребенком.

*Цепочка зависимостей* - состояние, когда есть n-ное количество следующих последовательно друг за другом пар родитель-ребенок какой угодно длины. Пример, как может выглядеть цепочка зависимостей: 
```
const a = createNum(2);
const b = fromNum(a).depend(val => val + 10);
const c = fromNum(b).depend(val => val - 4);
const d = fromNum(c).depend(val => val * 2);
const e = fromNum(d).depend(val => val * 10);
```

*Цепочка правил зависимости* - зависимость одной сущности от другой может регулироваться не одним вызовом метода `depend`, а несколькими его вызовами подряд, в цепочке. Такую цепочку назовем цепочкой правил зависимости. Пример, как это может выглядеть:
```
const a = createNum(10);
const b = fromNum(a)
    .depend(val => val + 5)
    .depend(val => val - 3)
    .depend(val => val * 2)
```

P.S. На практике это более применимо, например, к массивам, об этом позже.

Правила-функции цепочки правил зависимости ребенка от родителя хранятся списком внутри свойства реактива `rules`. При обновлении занчения родителя для обновления значения ребенка фукнции из `rules` вызываются последовательно по технологии pipe https://wavelop.com/en/story/javascript-pipe-function/.

*Пустая зависимость* - может быть и так, что какая-либо сущность зависит от другой, но у нее нет правила зависимости. Такую зависимсоть назовем пустой зависимостью. Это означает, что сущность по факту зависит от другой, но без правила. В этом случае если внутри цепочки зависимостей будет пустая зависимость, и за ней в цепочке зависимостей следует непустая зависимость, то правило-коллбэк этой непустой зависимости будет применяться к ближайшей родительской непустой сущности, если смотреть по в цепочке зависимсотей вверх. То есть в качестве аргументов в правило будут попадать значения ближайших непустых родителей, если смотреть по цепочке вверх. Данный функционал реализован через свойство closestNonEmptyParents, которое и хранит список ближайших верхних непустых родителей. 
Пример на практике:
```
const a = createNum(1);
const b = createNum(2);
const c = fromNum(a, b);
const d = fromNum(c);
const e = fromNum(d);
const f = fromNum(e)
const g = fromNum(f).depend((valA, b) => valA + b + 7);
```

В этом примере во время изменении `g` в качестве аргументов в правило `g` попадают значения реактивов `a` и `b` как ближайших врехних непутсых родителей.

*Нестрогая зависимость* - по умолчанию все зависмости в библиотеке строгие, это значит, что если величина зависима, то мы напрямую не можем ее изменить (исключения при попытке не будет, просто значение не поменяется). Но мы можем сделать зависимость нестрогой, это значит, что мы зависимую величину можем сами изменить напрямую как мы хотим. Но как только поменяем ее родителя, то зависимая величина поменяется в соответствии с правилом зависмости. Как реализуется: в метод `depend` вторым необязательным параметром передаем объект `options` - `{isStrict: boolean}`. У реактива есть соответсвующее свойство `isStrict`, равное по умолчанию `true`;

# API

*Общий класс реактива*